<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>vue | 好困啊</title><meta name="author" content="kill zou"><meta name="copyright" content="kill zou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="vue">
<meta property="og:type" content="article">
<meta property="og:title" content="vue">
<meta property="og:url" content="http://example.com/post/c0add594.html">
<meta property="og:site_name" content="好困啊">
<meta property="og:description" content="vue">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cli.vuejs.org/favicon.png">
<meta property="article:published_time" content="2023-05-02T01:39:59.635Z">
<meta property="article:modified_time" content="2023-05-09T06:03:30.958Z">
<meta property="article:author" content="kill zou">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cli.vuejs.org/favicon.png"><link rel="shortcut icon" href="/zoublong/img/ball.png"><link rel="canonical" href="http://example.com/post/c0add594.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/zoublong/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/zoublong/',
  algolia: undefined,
  localSearch: {"path":"/zoublong/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: kill zou","link":"链接: ","source":"来源: 好困啊","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vue',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-05-09 14:03:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="referrer" content="no-referrer"><link rel="stylesheet" href="/zoublong/config/css/r1.css""><link rel="stylesheet" href="/zoublong/config/css/universe.css"><link rel="stylesheet" href="/zoublong/config/css/fap.css"><link rel="stylesheet" href="/zoublong/config/css/scroll.css"><link rel="stylesheet" href="/zoublong/config/css/snow.css"><link rel="stylesheet" href="/zoublong/config/css/curr.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><console class="log" theme.preloader.source="theme.preloader.source" 555="555"></console><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/zoublong/config/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://p1.music.126.net/bKM7itpIqu_G2cA4BwdHmw==/109951168552935844.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/zoublong/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/zoublong/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/zoublong/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/"><i class="fa-fw icon-mihoutao"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mihoutao"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/archives/"><i class="fa-fw icon-huolongguo"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-huolongguo"></use></svg><span> 档案</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/tags/"><i class="fa-fw icon-shanzhu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shanzhu"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/categories/"><i class="fa-fw icon-caomei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-caomei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-li_huaban1"></use></svg><span> 逛逛</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/zoublong/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-baixiangguo">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/zoublong/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-niuyouguo">                   </use></svg><span> 壁纸</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/link/"><i class="fa-fw icon-yingtao"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yingtao"></use></svg><span> 链接</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-juzi"></use></svg><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/zoublong/comments"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-ningmeng">                   </use></svg><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/zoublong/artitalk"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xigua">                   </use></svg><span> 哔哔</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cli.vuejs.org/favicon.png')"><nav id="nav"><span id="blog-info"><a href="/zoublong/" title="好困啊"><span class="site-name">好困啊</span></a></span><div id="menus"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:1.28em;width:1.28em;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-sousuo"><span> 搜索</span></use></svg></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/"><i class="fa-fw icon-mihoutao"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mihoutao"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/archives/"><i class="fa-fw icon-huolongguo"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-huolongguo"></use></svg><span> 档案</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/tags/"><i class="fa-fw icon-shanzhu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shanzhu"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/categories/"><i class="fa-fw icon-caomei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-caomei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-li_huaban1"></use></svg><span> 逛逛</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/zoublong/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-baixiangguo">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/zoublong/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-niuyouguo">                   </use></svg><span> 壁纸</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/zoublong/link/"><i class="fa-fw icon-yingtao"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yingtao"></use></svg><span> 链接</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-juzi"></use></svg><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/zoublong/comments"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-ningmeng">                   </use></svg><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/zoublong/artitalk"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xigua">                   </use></svg><span> 哔哔</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">vue</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-02T01:39:59.635Z" title="发表于 2023-05-02 09:39:59">2023-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-09T06:03:30.958Z" title="更新于 2023-05-09 14:03:30">2023-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/zoublong/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vue"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="1-vue的基本原理"><a href="#1-vue的基本原理" class="headerlink" title="1.vue的基本原理"></a>1.vue的基本原理</h4><p>Vue的基本原理是采用响应式的<strong>数据绑定和组件化</strong>的思想，<strong>通过数据的变化驱动视图的自动更新</strong>。</p>
<p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty(vue3.0使用proxy)将它们转为getter&#x2F;setter，并在内部追踪相关依赖，以便在属性被访问和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而使它关联的组件得以更新。</p>
<p>Vue还支持组件化开发，每个组件都是一个Vue实例，通过组件之间的嵌套和引用来构建整个应用。组件可以拥有自己的状态和方法，还可以通过props属性接收来自父组件的数据，并通过事件机制与父组件通信。</p>
<p>总之，Vue的基本原理是通过响应式的数据绑定和组件化的思想来实现数据驱动视图的自动更新，从而让开发者可以更加专注于数据和业务逻辑的处理，而无需手动操作DOM元素。</p>
<h4 id="2-MVVM"><a href="#2-MVVM" class="headerlink" title="2.MVVM"></a>2.MVVM</h4><p>MVVM（Model-View-ViewModel）是一种前端架构模式，它将应用程序分为三个主要部分：<strong>Model、View和ViewModel。</strong>其中，Model代表<strong>数据和业务逻辑</strong>，View代表<strong>UI组件</strong>，而ViewModel则是Model和View之间的协调者。</p>
<p>在MVVM架构中，View是通过绑定ViewModel的属性和命令来实现的，ViewModel通过数据绑定将View和Model连接起来。当ViewModel的属性发生变化时，它会通知View进行更新，而当View触发事件时，ViewModel则会响应并更新Model的数据。</p>
<p>Vue.js就是一种基于MVVM架构的前端框架，它提供了一套响应式数据绑定和组件化系统，使开发者能够更加高效地构建复杂的用户界面。</p>
<p>优点：</p>
<p>MVVM 的优点主要包括：</p>
<ol>
<li><p>分离视图逻辑和业务逻辑，使得代码更易于<strong>维护和扩展</strong>。</p>
</li>
<li><p>双向绑定，自动更新视图，<strong>简化了 DOM 操作</strong>，提高了开发效率。</p>
</li>
<li><p><strong>数据与视图的分离</strong>，使得开发人员可以更加专注于数据和业务逻辑的处理，提高了开发效率。</p>
</li>
<li><p>视图模型可以被<strong>复用</strong>，多个视图可以共享同一个视图模型。</p>
</li>
<li><p>MVVM 框架提供了<strong>丰富的工具和生态</strong>，如 Vue.js、Angular.js 等，可以加速开发过程。</p>
</li>
</ol>
<h5 id="MVC："><a href="#MVC：" class="headerlink" title="MVC："></a>MVC：</h5><p>MVC是Model-View-Controller（模型-视图-控制器）的缩写，是一种软件设计模式。在MVC模式中，软件应用被分为三个核心部分：</p>
<ol>
<li><p>模型（Model）：负责管理应用程序的数据和相关行为。</p>
</li>
<li><p>视图（View）：负责显示应用程序的用户界面。</p>
</li>
<li><p>控制器（Controller）：负责接收用户的输入并调用模型和视图来执行用户的请求。</p>
</li>
</ol>
<p>MVC模式将应用程序分为三个独立的部分，使得各部分之间的耦合度降低，各部分可以独立变更而不会影响到其它部分，从而使得软件应用更加易于维护和扩展。</p>
<p>总的来说，MVC模式主要是用于构建传统的桌面应用程序。对于Web应用程序来说，由于Web页面的生命周期和用户交互模式的特殊性，MVC模式并不是最佳的设计模式。因此，在Web开发中，一些新的模式和架构被提出，如MVP和MVVM。</p>
<p>总之，MVC模式是一种优秀的软件设计模式，但在Web开发中，可能不是最佳的选择。</p>
<h5 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h5><p>在 MVVM 中，ViewModel 使用双向数据绑定将 View 中的数据绑定到 ViewModel 中的属性上，从而实现了 View 和 Model 的自动同步。这种自动同步的机制可以减少手动操作，提高开发效率和应用程序的可维护性。</p>
<p>总的来说，MVVM 相比 MVC 有以下优点：</p>
<ul>
<li>关注点分离更加彻底，Model、View 和 ViewModel 之间的<strong>耦合度更低</strong>。</li>
<li>双向数据绑定可以减少手动操作，提高开发效率和应用程序的可维护性。</li>
<li>ViewModel 可以提供更加<strong>灵活和复杂的逻辑处理</strong>，实现更加复杂的业务需求。</li>
</ul>
<p>不过，MVVM 的实现需要较为复杂的框架支持，而且在一些场景下可能会带来一些性能问题。因此，选择 MVC 还是 MVVM，需要根据实际场景进行考虑。</p>
<h4 id="3-双向数据绑定原理"><a href="#3-双向数据绑定原理" class="headerlink" title="3.双向数据绑定原理"></a>3.双向数据绑定原理</h4><p><strong>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调</strong></p>
<p>在MVVM架构中，实现双向数据绑定的核心是一个叫做“<strong>数据劫持”</strong>的技术。具体来说，当Vue实例化一个组件时，Vue会对数据对象进行递归地遍历，把每个属性都通过Object.defineProperty()方法转换为getter和setter，这样当属性的值被修改时，会触发setter方法，从而通知到数据对象的订阅者，告知数据变化，再通过更新视图的操作来保证数据和视图的同步。</p>
<p>简单来说，双向数据绑定的实现原理就是通过数据劫持技术来监听数据的变化，从而更新视图，也通过监听视图的变化来更新数据。这种机制使得开发者可以更加方便地操作数据和视图，提高了开发效率。</p>
<h5 id="如何实现的："><a href="#如何实现的：" class="headerlink" title="如何实现的："></a>如何实现的：</h5><p>双向数据绑定是指在视图层和数据层之间进行同步更新的一种机制。实现双向数据绑定的方式有多种，下面介绍其中一种常见的实现方式：</p>
<p>1、<strong>需要observer的数据对象进行递归遍历</strong>，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>
<p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br> (1)在自身实例化时往属性订阅器(dep)里面添加自己<br> (2)自身必须有一个update()方法<br> (3)待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
<p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果</p>
<p>这种方式的优点是能够自动实现数据和视图的同步更新，使得开发人员不需要手动操作 DOM，提高了开发效率。缺点是实现起来比较复杂，而且可能会带来一定的性能问题。</p>
<p>下面是一个简单的双向数据绑定的实现：</p>
<p>HTML：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;input&quot; value=&quot;&quot;&gt;</span><br><span class="line">  &lt;p id=&quot;output&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const app = document.querySelector(&#x27;#app&#x27;);</span><br><span class="line">const input = document.querySelector(&#x27;#input&#x27;);</span><br><span class="line">const output = document.querySelector(&#x27;#output&#x27;);</span><br><span class="line"></span><br><span class="line">let data = &#123;</span><br><span class="line">  message: &#x27;&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(data, &#x27;message&#x27;, &#123;</span><br><span class="line">  get: function () &#123;</span><br><span class="line">    return this._message;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (newValue) &#123;</span><br><span class="line">    this._message = newValue;</span><br><span class="line">    output.innerHTML = newValue;</span><br><span class="line">    input.value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.addEventListener(&#x27;keyup&#x27;, function (event) &#123;</span><br><span class="line">  data.message = event.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先定义了一个数据对象 <code>data</code>，它包含了一个字符串类型的属性 <code>message</code>。然后使用 <code>Object.defineProperty()</code> 方法将这个属性转化为一个 getter&#x2F;setter，并且在 setter 中更新绑定到这个属性的 HTML 元素的值。</p>
<p>接着，我们给输入框 <code>input</code> 添加了一个 <code>keyup</code> 事件监听器，当用户在输入框中输入时，会触发这个事件监听器并且更新 <code>data.message</code> 的值，进而更新绑定到这个属性的 HTML 元素的值。</p>
<p>这样，当用户在输入框中输入时，页面上的 <code>p</code> 元素的值也会同步更新。反过来，如果我们在 JavaScript 中修改 <code>data.message</code> 的值，输入框中的值也会自动更新。这就是一个简单的双向数据绑定的实现。</p>
<p><strong>简答：</strong></p>
<p>  首先，Vue通过Object.defineProperty()方法对数据进行劫持，监听数据的变化，并通过getter和setter方法对数据进行读写。<br>其次，Vue通过发布订阅模式，维护了一个订阅者数组，当数据发生变化时，Vue会通知所有订阅者进行更新。因此，当用户在页面上进行修改时，Vue会更新对应的数据，并更新所有订阅者更新视图，同时当数据发生变化时，Vue也会更新对应的视图，通过这样的机制，Vue实现了双向数据绑定，使得数据和视图的变化可以互相影响</p>
<p>补充：订阅者是Vue中的一个概念，它是一个用于管理更新视图的对象，当数据发生变化时，Vue会通知所有的订阅者进行更新，在Vue中，每一个挂载到视图上的组件，或者每一个watcher，都可以被看成一个订阅者，他们订阅了某一个数据的变化，并等待数据发生变化时进行更新，订阅者是Vue实现双向数据绑定的关键组成部分，管理着数据和视图之间的关系，保证了数据的变化能够及时反应到视图上  </p>
<h5 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h5><p>Vue 3使用了Proxy来实现响应式系统，相较于Vue 2的Object.defineProperty，Proxy具有更好的性能和功能，更加符合直觉。</p>
<p>当创建一个响应式对象时，Vue 3会将原始对象用Proxy进行包装，并返回这个代理对象。在代理对象上进行属性的读取和修改操作时，会触发代理对象的get和set拦截器函数，这些拦截器函数负责收集依赖和派发更新。</p>
<p>Vue 3 中的数据劫持使用的是 JavaScript 原生的 Proxy 对象。Proxy 对象可以拦截并定义基本操作，比如读取属性（get）、写入属性（set）、删除属性（delete）等等。</p>
<p>Vue 3 在创建组件实例时，会将组件实例的 data 对象转换成响应式对象。这个过程是在 createDataProxy 函数中实现的。具体的过程如下：</p>
<ol>
<li><p>在 createDataProxy 函数中，使用 Proxy 对数据对象进行包装，返回一个代理对象。这个代理对象会拦截所有对数据对象的访问操作。</p>
</li>
<li><p>对于每个属性，如果它的值是一个对象，就对它进行递归处理，使它的属性也变成响应式。</p>
</li>
<li><p>在代理对象中，对数据对象的每个属性进行劫持，当属性被访问或修改时，会触发代理对象上的 get 和 set 方法。</p>
</li>
<li><p>在 get 方法中，通过 Reflect.get 方法获取属性值，并返回。在此时，如果存在当前的渲染 watcher 对象，会将这个渲染 watcher 对象加入到属性的依赖列表中。</p>
</li>
<li><p>在 set 方法中，先使用 Reflect.set 方法修改属性的值，然后通知属性的依赖列表更新，更新组件视图。</p>
</li>
</ol>
<p>下面是一个简单的 Vue 3 数据劫持的实现示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">      <span class="title function_">track</span>(target, key) <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">      <span class="title function_">trigger</span>(target, key) <span class="comment">// 触发更新</span></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖收集</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeEffect = fn</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      dep = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, dep)</span><br><span class="line">    &#125;</span><br><span class="line">    dep.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发更新</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (depsMap) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">      dep.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">effect</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span>++</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用了 Proxy 对象对数据进行了劫持，并通过 effect 函数来收集依赖和触发更新。这是 Vue 3 中实现数据响应式的核心机制。</p>
<h5 id="Object-defineProperty-的缺点"><a href="#Object-defineProperty-的缺点" class="headerlink" title="Object.defineProperty()的缺点"></a>Object.defineProperty()的缺点</h5><p>以下是 <code>Object.defineProperty()</code> 的缺点总结：</p>
<ol>
<li><p><strong>兼容性问题：</strong> <code>Object.defineProperty()</code> 是 ES5 中新增的 API，它只支持现代浏览器，无法兼容 IE8 及以下的浏览器。</p>
</li>
<li><p><strong>性能问题：</strong> <code>Object.defineProperty()</code> 虽然能够对对象属性进行拦截，但每次拦截时都会创建一个新的 getter 和 setter，这会导致对象的访问和赋值变慢，尤其是在大量属性时。</p>
</li>
<li><p><strong>只能监听已经存在的属性：</strong> <code>Object.defineProperty()</code> 只能监听已经存在的属性，无法监听动态添加的属性，因此需要使用额外的方式来实现对动态属性的监听。</p>
</li>
<li><p><strong>存在浅监听问题：</strong> <code>Object.defineProperty()</code> 只能劫持对象属性的读取和赋值操作，而无法劫持对象属性内部属性的变化，因此需要额外的处理来实现深度监听。</p>
</li>
</ol>
<p>综上所述，<code>Object.defineProperty()</code> 虽然具有对对象属性进行劫持的能力，但在使用时需要注意上述缺点，并结合实际情况选择合适的方案。</p>
<h5 id="vue-set是实现的原理"><a href="#vue-set是实现的原理" class="headerlink" title="vue.$set是实现的原理"></a>vue.$set是实现的原理</h5><p>Vue 中的 <code>$set</code> 方法实现动态添加属性的监听，是通过调用内部方法 <code>_defineReactive()</code> 和 <code>_additionnalGetter()</code> 来实现的。具体来说，当我们使用 <code>$set</code> 方法动态添加一个属性时，Vue 会执行以下操作：</p>
<ol>
<li><p>判断当前对象是否是响应式对象，如果不是，将其转化为响应式对象。</p>
<p>在 Vue 中，一个对象是否是响应式对象，是通过判断该对象是否有 <code>__ob__</code> 属性来进行的。<code>__ob__</code> 属性是在对象被转化为响应式对象时添加的，用于保存响应式系统的一些相关信息。因此，当我们使用 <code>$set</code> 方法向一个普通对象添加属性时，Vue 会先判断该对象是否有 <code>__ob__</code> 属性，如果没有，就使用 <code>observe()</code> 方法将其转化为响应式对象。</p>
</li>
<li><p>使用 <code>Object.defineProperty()</code> 方法将新增的属性转化为响应式属性。</p>
<p>在将新增的属性转化为响应式属性时，Vue 会调用内部方法 <code>_defineReactive()</code> 来进行转化。该方法接受三个参数：<code>obj</code> 表示要将属性添加到的对象，<code>key</code> 表示要添加的属性名，<code>val</code> 表示要添加的属性值。在该方法中，Vue 使用 <code>Object.defineProperty()</code> 方法将新增的属性转化为响应式属性，并将其添加到对象的依赖列表中。</p>
</li>
<li><p>使用 <code>_additionnalGetter()</code> 方法为新增的属性添加 getter 方法。</p>
<p>在 Vue 中，为了能够自动更新组件，每个响应式属性都需要有一个 getter 方法来进行依赖追踪。但是，由于新增的属性原本并没有 getter 方法，因此需要使用 <code>_additionnalGetter()</code> 方法来为其添加一个 getter 方法。该方法会向对象的 <code>getter</code> 集合中添加一个 getter 方法，该方法会返回新增属性的值。</p>
</li>
</ol>
<p>总之，在 Vue 中，使用 <code>$set</code> 方法向已经被监听的对象添加属性，是通过调用内部方法 <code>_defineReactive()</code> 和 <code>_additionnalGetter()</code> 来实现的。这两个方法的作用分别是将新增的属性转化为响应式属性，并为其添加一个 getter 方法，从而实现对新增属性的监听。</p>
<h4 id="4-vue-computed-和watch"><a href="#4-vue-computed-和watch" class="headerlink" title="4.vue computed 和watch"></a>4.vue computed 和watch</h4><p>Computed 和 Watch 都是 Vue 中用于监听数据变化的 API，它们的作用虽然有些类似，但是它们的实现方式和使用场景却有所不同。</p>
<p>Computed 是一种<strong>基于依赖关系自动更新的计算属性，可以根据其所依赖的数据动态计算出新的值，并缓存计算结果。</strong>它的使用方式类似于一个函数，只不过它的返回值会被缓存起来，只有当它所依赖的数据发生变化时才会重新计算。Computed 可以帮助我们减少模板中复杂表达式的使用，使代码更加简洁和易读。</p>
<p>Watch 则是一种响应式的数据监听机制，可以<strong>监听一个数据的变化，并在数据变化时执行一些特定的操作。</strong>它的使用方式类似于一个回调函数，可以在数据变化时执行一些异步操作，或者执行一些复杂的计算逻辑。与 Computed 不同，Watch 监听的数据变化不一定与模板渲染有关，它可以用于实现数据的持久化、远程数据同步等功能。</p>
<p>总之，Computed 适用于计算属性、模板中复杂表达式的计算等场景，而 Watch 则适用于数据变化时的特定操作，如异步操作、复杂计算逻辑等场景。同时，需要注意的是，在 Vue 中，Computed 是基于 Watch 实现的，也就是说，Computed 本质上是一个 Watcher，只不过它具有缓存功能，可以根据依赖关系自动更新。</p>
<p>总结：</p>
<p>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</p>
<p>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</p>
<h4 id="5-slot是什么？有什么作用？原理是什么？"><a href="#5-slot是什么？有什么作用？原理是什么？" class="headerlink" title="5.slot是什么？有什么作用？原理是什么？"></a>5.slot是什么？有什么作用？原理是什么？</h4><p>在 Vue 中，slot 是一种用于组件化开发的特殊语法，它允许组件在其模板中预留一些位置，以便父组件在使用该组件时向其传递内容。slot 可以理解为组件的插槽，用于在组件中动态插入内容。</p>
<p>slot 的作用主要有以下几个方面：</p>
<ol>
<li><p><strong>组件复用</strong>：使用 slot 可以使组件更加灵活和通用，不同的父组件可以向同一个组件传递不同的内容，从而实现不同的功能。</p>
</li>
<li><p><strong>嵌套组件</strong>：使用 slot 可以使组件之间嵌套更加灵活和自由，不同的子组件可以向同一个父组件传递不同的内容，从而实现不同的呈现方式。</p>
</li>
<li><p><strong>插件式开发</strong>：使用 slot 可以使组件更加像插件一样开发，父组件可以通过插槽将自定义的内容传递给组件，从而实现不同的功能和效果。</p>
</li>
</ol>
<p>slot 的原理是基于 Vue 的组件化机制，每个组件都可以有自己的模板和数据，而 slot 允许父组件向子组件中插入内容，从而实现动态化和灵活性。当一个组件使用了 slot 时，它会在组件的模板中使用特殊的标记定义一个或多个插槽，然后在父组件中使用该组件时，可以通过标记的名称向插槽中插入内容。在渲染过程中，Vue 会根据父组件传递给子组件的内容动态地替换插槽中的内容，从而实现组件的灵活和动态化。</p>
<p>需要注意的是，在 Vue 中，slot 还有具名插槽和作用域插槽等不同类型，它们具有不同的用法和功能。同时，在使用 slot 时，需要注意其作用域和数据传递等问题，避免出现不必要的问题和错误。</p>
<h4 id="6-vue生命周期"><a href="#6-vue生命周期" class="headerlink" title="6.vue生命周期"></a>6.vue生命周期</h4><p><img src="https://s1.vika.cn/space/2023/05/06/47d88708ba0049d282c8c965abed919d"></p>
<p>Vue 生命周期是指 Vue 实例在创建、运行和销毁时所经过的各个阶段。理解 Vue 生命周期可以帮助开发者在开发过程中更好地控制和管理组件的状态和行为，以及进行一些必要的操作和优化。</p>
<p>Vue 生命周期可以分为以下几个阶段：</p>
<ol>
<li><p><strong>创建阶段</strong>：在这个阶段，Vue 实例会进行初始化，并且在 DOM 上生成对应的模板。在这个阶段中，主要包括 beforeCreate、created 和 beforeMount 三个生命周期钩子函数，分别表示实例初始化前、实例创建后和模板挂载前的时刻。</p>
</li>
<li><p><strong>挂载阶段</strong>：在这个阶段，Vue 实例会将生成的模板渲染到页面上，并且与 DOM 进行绑定。在这个阶段中，主要包括 mounted 钩子函数，表示模板挂载后的时刻。</p>
</li>
<li><p><strong>更新阶段</strong>：在这个阶段，Vue 实例会对数据进行修改，并且对模板进行重新渲染。在这个阶段中，主要包括 beforeUpdate 和 updated 两个钩子函数，分别表示数据更新前和数据更新后的时刻。</p>
</li>
<li><p><strong>销毁阶段</strong>：在这个阶段，Vue 实例会进行销毁和清理，以及解除与 DOM 的绑定。在这个阶段中，主要包括 beforeDestroy 和 destroyed 两个钩子函数，分别表示实例销毁前和实例销毁后的时刻。</p>
</li>
</ol>
<h5 id="vue3的生命周期"><a href="#vue3的生命周期" class="headerlink" title="vue3的生命周期"></a>vue3的生命周期</h5><p>Vue 3 的生命周期相对于 Vue 2 有些不同，主要是由于 Vue 3 引入了 Composition API，提供了一种新的组合式 API 风格，取代了 Vue 2 中的 Options API。因此，Vue 3 的生命周期也发生了相应的变化。</p>
<p>Vue 3 的生命周期可以分为以下几个阶段：</p>
<ol>
<li><p><strong>创建阶段</strong>：在这个阶段，Vue 实例会进行初始化，并且在 DOM 上生成对应的模板。在这个阶段中，主要包括 <strong>setup</strong> 和 <strong>onBeforeMount</strong> 两个生命周期钩子函数，分别表示实例初始化后和模板挂载前的时刻。</p>
</li>
<li><p><strong>挂载阶段</strong>：在这个阶段，Vue 实例会将生成的模板渲染到页面上，并且与 DOM 进行绑定。在这个阶段中，主要包括 <strong>onMounted</strong> 钩子函数，表示模板挂载后的时刻。</p>
</li>
<li><p><strong>更新阶段</strong>：在这个阶段，Vue 实例会对数据进行修改，并且对模板进行重新渲染。在这个阶段中，主要包括 <strong>onBeforeUpdate</strong> 和 <strong>onUpdated</strong> 两个钩子函数，分别表示数据更新前和数据更新后的时刻。</p>
</li>
<li><p><strong>卸载阶段</strong>：在这个阶段，Vue 实例会进行销毁和清理，以及解除与 DOM 的绑定。在这个阶段中，主要包括 <strong>onBeforeUnmount</strong> 和 <strong>onUnmounted</strong> 两个钩子函数，分别表示实例卸载前和实例卸载后的时刻。</p>
</li>
</ol>
<p>需要注意的是，Vue 3 中的生命周期钩子函数都是通过 Composition API 来实现的，而且有些钩子函数名称也有所改变，例如 beforeCreate 在 Vue 3 中被改名为 setup，这些变化也使得开发者需要适应新的生命周期钩子函数名称和用法。</p>
<h5 id="多组件（父子组件）中生命周期的调用顺序"><a href="#多组件（父子组件）中生命周期的调用顺序" class="headerlink" title="多组件（父子组件）中生命周期的调用顺序"></a>多组件（父子组件）中生命周期的调用顺序</h5><p><strong>加载渲染过程</strong>：父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</p>
<p><strong>子组件更新过程</strong>：父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p>
<p><strong>父组件更新过程</strong>：父 beforeUpdate -&gt; 父 updated</p>
<p><strong>销毁过程</strong>：父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>
<h4 id="7-v-model双向绑定"><a href="#7-v-model双向绑定" class="headerlink" title="7.v-model双向绑定"></a>7.v-model双向绑定</h4><p><code>v-model</code> 是 Vue.js 提供的一个语法糖，它能够在表单控件和 Vue 实例之间建立双向绑定关系。在使用 <code>v-model</code> 绑定表单控件时，用户输入的内容会自动同步到 Vue 实例的数据属性中，同时当 Vue 实例的数据属性发生变化时，表单控件中的值也会随之更新。</p>
<p><code>v-model</code> 的实现原理是通过组合使用 <code>v-bind</code> 和 <code>v-on</code> 来实现的。当我们在一个表单控件上使用 <code>v-model</code> 时，实际上是在该表单控件上绑定了一个 <code>value</code> 属性和一个 <code>input</code> 事件。具体来说，<code>v-model</code> 会将表单控件的 <code>value</code> 属性与 Vue 实例中的数据属性进行绑定，同时在表单控件上监听 <code>input</code> 事件，当用户输入内容时，<code>input</code> 事件会被触发，从而将用户输入的内容更新到 Vue 实例的数据属性中。</p>
<p>例如，在下面的代码中，我们使用 <code>v-model</code> 绑定了一个输入框：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>v-model</code> 绑定了一个输入框，它将输入框的 <code>value</code> 属性与 Vue 实例中的 <code>message</code> 数据属性进行了双向绑定。当用户在输入框中输入内容时，<code>input</code> 事件会被触发，从而将输入框中的值同步到 Vue 实例的 <code>message</code> 属性中，而在 <code>&#123;&#123; message &#125;&#125;</code> 中显示的内容也会随之更新。</p>
<p>总的来说，<code>**v-model</code> 实现双向绑定的原理就是通过在表单控件上绑定 <code>value</code> 属性和监听 <code>input</code> 事件**，将用户输入的内容同步到 Vue 实例的数据属性中，同时在 Vue 实例的数据属性发生变化时，将变化的数据同步到表单控件中。</p>
<h4 id="8-vue-router"><a href="#8-vue-router" class="headerlink" title="8.vue-router"></a>8.vue-router</h4><h5 id="1-hash和history的区别"><a href="#1-hash和history的区别" class="headerlink" title="1.hash和history的区别"></a>1.hash和history的区别</h5><p>在 Vue Router 中，路由模式有两种：Hash 模式和 History 模式。</p>
<p><strong>Hash 模式</strong></p>
<p>在 Hash 模式下，URL 中的路径部分以 <code>#</code> 字符开头，例如：<code>http://localhost:8080/#/home</code>。这个 <code>#</code> 符号实际上是浏览器的锚点（anchor）的一种使用方式。浏览器在加载页面时，如果 URL 中包含 <code>#</code> 字符，它会自动滚动到相应的锚点处，不会对服务器发起请求。</p>
<p>在 Vue Router 中，当切换路由时，路由器会通过改变 URL 中的 hash 值来实现路由的跳转。当我们使用 <code>vue-router</code> 提供的 <code>router-link</code> 标签进行路由跳转时，实际上就是改变 URL 中的 hash 值，<strong>并通过监听 <code>window</code> 对象的 <code>hashchange</code> 事件来实现路由切换。</strong></p>
<p><strong>History 模式</strong></p>
<p>在 History 模式下，URL 中的路径部分不再以 <code>#</code> 字符开头，而是以实际的 URL 路径来表示，例如：<code>http://localhost:8080/home</code>。这种模式下，<strong>我们可以使用浏览器提供的 HTML5 API—— <code>history.pushState()</code> 和 <code>history.replaceState()</code> 来改变浏览器地址栏的 URL</strong>，而不会向服务器发起请求。</p>
<p>在 Vue Router 中，当我们使用 History 模式时，当切换路由时，路由器会通过调用 <code>history.pushState()</code> 和 <code>history.replaceState()</code> 方法来改变浏览器地址栏的 URL，并通过监听 <code>popstate</code> 事件来实现路由的切换。这个 <code>popstate</code> 事件会在浏览器的前进和后退按钮被点击时触发。</p>
<p>需要注意的是，当使用 History 模式时，我们需要在后端服务器上进行相应的配置，以便让服务器能够正确地处理路由请求。在使用 Vue CLI 创建的项目中，我们可以通过在 <code>vue.config.js</code> 文件中设置 <code>historyApiFallback: true</code> 来开启后端路由的支持。</p>
<h5 id="router和route的区别"><a href="#router和route的区别" class="headerlink" title="router和route的区别"></a>router和route的区别</h5><p><code>router</code> 和 <code>route</code> 是 <code>Vue Router</code> 中的两个概念，分别表示路由器和路由。</p>
<ul>
<li><p><code>router</code>：路由器，<strong>用于管理应用程序的路由</strong>，包含了<strong>路由的定义、匹配、转换等功能</strong>。我们可以通过实例化 <code>VueRouter</code> 对象来创建一个路由器，然后在 <code>Vue</code> 实例中注入该路由器，从而让整个应用程序能够使用它来进行路由的管理。</p>
</li>
<li><p><code>route</code>：路由，<strong>表示当前激活的路由信息</strong>，包含了该路由的路径、参数、查询、hash 等信息。在 <code>Vue</code> 组件中，我们可以通过访问 <code>$route</code> 对象来获取当前激活的路由信息，从而进行一些逻辑处理或者展示。</p>
</li>
</ul>
<p>总的来说，<code>router</code> 是<strong>整个应用程序的路由管理器</strong>，而 <code>route</code> 则是表示当前激活的路由的信息对象。</p>
<h5 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h5><p>在 Vue Router 中，导航守卫（navigation guard）是用于控制路由跳转的一种机制，它可以在路由切换前、路由切换后、以及路由切换被取消时执行一些特定的操作，例如验证用户身份、数据加载、页面滚动等等。</p>
<p>Vue Router 中的导航守卫有以下几种类型：</p>
<ol>
<li><p>全局前置守卫：<code>beforeEach</code>。它会在每次路由切换前被调用，可以用来进行一些<strong>全局的拦截和校验操作</strong>。</p>
</li>
<li><p>全局解析守卫：<code>beforeResolve</code>。它会在路由被确认之前，异步路由组件被解析之后被调用。</p>
</li>
<li><p>全局后置钩子：<code>afterEach</code>。它会在每次路由切换完成后被调用，可以用来进行一些全局的收尾工作。</p>
</li>
<li><p>路由独享的守卫：<code>beforeEnter</code>。它会在路由被确认之前被调用，可以用来进行一些单独路由的拦截和校验操作。</p>
</li>
<li><p>组件内的守卫：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code>。它们分别会在进入路由、路由参数变化、离开路由时被调用，可以用来进行组件级别的拦截和校验操作。</p>
</li>
</ol>
<p>需要注意的是，路由守卫中可以使用 <code>next</code> 方法来控制路由跳转的行为，<code>next</code> 方法可以接受一个参数，用来指定下一步要跳转到的路由或者取消路由跳转。</p>
<h4 id="9-v-if-与-v-show-的区别"><a href="#9-v-if-与-v-show-的区别" class="headerlink" title="9.v-if 与 v-show 的区别"></a>9.v-if 与 <em>v-show</em> 的区别</h4><p><code>v-if</code> 和 <code>v-show</code> 都是 <code>Vue</code> 模板中用于控制元素显示或隐藏的指令，它们的实现原理和使用场景有所不同：</p>
<ol>
<li><p><code>v-if</code>：<strong>根据表达式的值的真假来决定是否渲染元素</strong>，如果为 <code>false</code> 则元素不会被渲染到页面上，如果为 <code>true</code> 则会被渲染到页面上。<code>v-if</code> 的<strong>切换开销比较大</strong>，因为它会在条件发生改变时重新销毁和创建元素，所以适用于不经常切换的场景。</p>
</li>
<li><p><code>v-show</code>：<strong>根据表达式的值的真假来决定元素是否显示</strong>，如果为 <code>false</code> 则元素会被隐藏，但是依然会被渲染到页面上，如果为 <code>true</code> 则会显示出来。<code>v-show</code> 的切换开销比较小，因为它只是简单的修改元素的 <code>display</code> 样式属性来实现显示或隐藏，所以适用于经常切换的场景。</p>
</li>
</ol>
<p>因此，如果需要频繁切换元素的显示或隐藏状态，可以使用 <code>v-show</code> 来优化性能，而如果元素的显示或隐藏状态不经常发生变化，可以使用 <code>v-if</code> 来实现条件渲染。</p>
<h4 id="10-v-if和v-for的优先级"><a href="#10-v-if和v-for的优先级" class="headerlink" title="10.v-if和v-for的优先级"></a>10.v-if和v-for的优先级</h4><p>在 Vue 模板中，<code>v-for</code> 的优先级高于 <code>v-if</code>。这意味着，如果在同一个元素上同时使用了 <code>v-for</code> 和 <code>v-if</code>，则 <code>v-for</code> 会先被解析执行，然后才是 <code>v-if</code>。</p>
<p>这种行为可能会导致一些问题，例如，如果 <code>v-for</code> 的数据源是空数组，那么即使 <code>v-if</code> 中的条件为 <code>true</code>，也不会渲染任何元素。因此，在使用 <code>v-for</code> 和 <code>v-if</code> 时需要格外注意。</p>
<p>如果需要在某些情况下跳过循环的某些元素，可以将 <code>v-if</code> 放到循环内部的元素上。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;item.visible&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，只有在 <code>item.visible</code> 为 <code>true</code> 时，才会渲染 <code>div</code> 元素。这样就可以实现跳过某些元素的效果。</p>
<ul>
<li><strong>在 vue 2.x 中，在一个元素上同时使用 <code>v-if</code> 和 <code>v-for</code> 时，<code>v-for</code> 会优先作用。</strong></li>
<li><strong>在 vue 3.x 中，<code>v-if</code> 总是优先于 <code>v-for</code> 生效。</strong></li>
</ul>
<h4 id="11-keep-alive"><a href="#11-keep-alive" class="headerlink" title="11.keep-alive"></a>11.keep-alive</h4><h5 id="keep-alive的实现原理是什么"><a href="#keep-alive的实现原理是什么" class="headerlink" title="keep-alive的实现原理是什么"></a><strong>keep-alive的实现原理是什么</strong></h5><p><code>keep-alive</code> 是 Vue <strong>内置的一个组件，用于缓存动态组件或者路由组件，避免组件被频繁销毁和创建，从而提高应用的性能和用户体验</strong>。它的实现原理如下：</p>
<ol>
<li><p>首次渲染：当一个被 <code>keep-alive</code> 包裹的组件被渲染时，会触发 <code>activated</code> 生命周期钩子函数，并将组件的状态设置为 <code>active</code>。</p>
</li>
<li><p>缓存组件：当一个被 <code>keep-alive</code> 包裹的组件被切换到其他组件时，不会直接被销毁，而是被缓存到内存中，等待下一次重新激活。此时，组件的状态被设置为 <code>inactive</code>。</p>
</li>
<li><p>再次渲染：当再次切换回被缓存的组件时，会触发 <code>activated</code> 生命周期钩子函数，并将组件的状态设置为 <code>active</code>，然后直接从内存中读取缓存的组件，并将其重新挂载到页面上，而不是重新创建。</p>
</li>
<li><p>清除缓存：如果一个被缓存的组件在一定时间内没有被访问过，或者内存不足时，<code>keep-alive</code> 会将其从内存中清除，以释放资源。</p>
</li>
</ol>
<p>需要注意的是，<code>keep-alive</code> 只能缓存有状态的组件（即带有数据或事件处理逻辑的组件），无状态组件（即只有渲染函数的组件）无法被缓存。此外，<code>keep-alive</code> 还支持一些属性和事件，例如 <code>include</code>、<code>exclude</code>、<code>max</code>、<code>exclude</code>、<code>v-slot</code> 等，可以用于进一步控制缓存的行为。</p>
<h5 id="与keep-alive相关的生命周期函数是什么，什么场景下会进行使用"><a href="#与keep-alive相关的生命周期函数是什么，什么场景下会进行使用" class="headerlink" title="与keep-alive相关的生命周期函数是什么，什么场景下会进行使用"></a><strong>与keep-alive相关的生命周期函数是什么，什么场景下会进行使用</strong></h5><p>与 <code>keep-alive</code> 相关的生命周期函数主要有两个，<strong>分别是 <code>activated</code> 和 <code>deactivated</code>，它们分别在缓存的组件被激活和停用时触发。</strong></p>
<ul>
<li><p><code>activated</code> 生命周期钩子函数：在缓存的组件被激活并插入页面时触发，可以用于在组件重新激活时执行一些操作，例如重新加载数据、重新初始化状态等。</p>
</li>
<li><p><code>deactivated</code> 生命周期钩子函数：在缓存的组件被停用并从页面中移除时触发，可以用于在组件被缓存时执行一些清理操作，例如清除定时器、取消请求等。</p>
</li>
</ul>
<p>使用场景：</p>
<p><code>keep-alive</code> 主要用于缓存动态组件或者路由组件，以避免组件被频繁销毁和创建，提高应用的性能和用户体验。它通常用于以下场景：</p>
<ul>
<li>在多个组件之间切换时，保留组件的状态和数据，避免重新加载和初始化。</li>
<li>在需要频繁显示和隐藏组件时，提高页面的渲染性能，避免页面卡顿。</li>
<li>在需要缓存一些常用组件或者页面时，减少服务器的负担，提高页面的响应速度。</li>
</ul>
<p>需要注意的是，在使用 <code>keep-alive</code> 时，被缓存的组件仍然会执行一部分生命周期钩子函数，例如 <code>created</code> 和 <code>mounted</code>，但是不会执行 <code>beforeDestroy</code> 钩子函数。因此，在使用 <code>keep-alive</code> 时，应该确保被缓存的组件能够正确处理这些钩子函数的调用。</p>
<h5 id="keep-alive的常用属性有哪些"><a href="#keep-alive的常用属性有哪些" class="headerlink" title="keep-alive的常用属性有哪些"></a>keep-alive的常用属性有哪些</h5><p>常用的属性有以下几个：</p>
<ul>
<li><p><code>include</code>：用于指定需要缓存的组件名称或者正则表达式。只有匹配到的组件才会被缓存。</p>
</li>
<li><p><code>exclude</code>：用于指定不需要缓存的组件名称或者正则表达式。匹配到的组件不会被缓存。</p>
</li>
<li><p><code>max</code>：用于指定缓存的最大组件数。当缓存的组件数超过该值时，最久未使用的组件会被销毁。</p>
</li>
<li><p><code>include-changed</code>：用于指定当组件的 props 或者 key 发生变化时，是否需要重新缓存该组件。默认情况下，只有组件的名称发生变化时才会重新缓存。</p>
</li>
<li><p><code>exclude-mode</code>：用于指定 <code>exclude</code> 属性的匹配模式。默认情况下，<code>exclude</code> 属性是以组件名称为匹配对象，如果设置为 <code>&quot;leaving&quot;</code>，则表示以组件实例为匹配对象。</p>
</li>
</ul>
<p>这些属性可以在 <code>keep-alive</code> 组件上直接使用，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;&#x27;componentA&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，只有名称为 <code>&quot;componentA&quot;</code> 的组件才会被缓存。其他组件不会被缓存。</p>
<h4 id="12-nextTick"><a href="#12-nextTick" class="headerlink" title="12.$nextTick"></a>12.$nextTick</h4><p><strong>vue 更新 DOM 是异步更新的，数据变化，DOM 的更新不会马上完成，nextTick 的回调是在下次 DOM 更新循环结束之后执行的延迟回调。</strong></p>
<p>实现原理：nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li>Promise：可以将函数延迟到当前函数调用栈最末端</li>
<li>MutationObserver ：是 H5 新加的一个功能，其功能是监听 DOM 节点的变动，在所有 DOM 变动完成后，执行回调函数</li>
<li>setImmediate：用于中断长时间运行的操作，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数</li>
<li>如果以上都不行则采用 setTimeout 把函数延迟到 DOM 更新之后再使用，原因是宏任务消耗大于微任务，优先使用微任务，最后使用消耗最大的宏任务。</li>
</ul>
<p>例如，以下代码在更新 <code>message</code> 数据后，使用 <code>$nextTick</code> 方法<strong>访问更新后的 DOM 元素</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;message&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateMessage&quot;</span>&gt;</span>Update Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;Hello, world!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">updateMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Hello, Vue!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">message</span>.<span class="property">textContent</span>) <span class="comment">// &quot;Hello, Vue!&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>updateMessage</code> 方法中，先更新了 <code>message</code> 数据，然后使用 <code>$nextTick</code> 方法访问更新后的 DOM 元素。这样就能够获取到更新后的内容。</p>
<h5 id="为什么要使用-nextTick"><a href="#为什么要使用-nextTick" class="headerlink" title="为什么要使用$nextTick"></a>为什么要使用$nextTick</h5><p>因为 vue 采用的异步更新策略，当监听到数据发生变化的时候不会立即去更新DOM，</p>
<p>而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更;</p>
<h4 id="13-data为什么是个函数"><a href="#13-data为什么是个函数" class="headerlink" title="13.data为什么是个函数"></a>13.data为什么是个函数</h4><p>在 Vue 组件中，<code>data</code> 选项的值必须是一个函数而不能直接是一个对象。这是因为 Vue.js 的组件实例是可复用的，如果多个组件实例都使用了同一个对象作为 <code>data</code> 选项的值，<strong>那么它们将共享同一个数据源，这会导致一个组件的数据变化也会影响到其他组件的数据，从而产生意料之外的副作用。</strong></p>
<p>将 <code>data</code> 选项的值设为一个函数可以解决这个问题。函数会被执行多次，<strong>每次执行都会返回一个新的对象作为数据源，这样每个组件实例都会拥有自己的数据源，不会受到其他组件的影响。</strong></p>
<p>具体来说，当我们在组件的选项中定义 <code>data</code> 选项时，Vue.js 会在创建组件实例时调用这个函数，从而生成一个新的数据源，并将它赋值给组件实例的 <code>data</code> 属性。因此，每个组件实例都会拥有自己的数据源，它们之间是相互独立的。</p>
<p>除了 <code>data</code> 选项之外，Vue.js 的 <code>props</code> 选项也建议使用函数的形式来定义。这是因为 <code>props</code> 选项的值也可能会被多个组件实例共享，使用函数可以避免共享数据源的问题，确保每个组件实例都拥有自己的数据源。</p>
<h4 id="14-spa的理解"><a href="#14-spa的理解" class="headerlink" title="14.spa的理解"></a>14.spa的理解</h4><p>SPA（Single-Page Application，<u>单页面应用</u>）指的是在<strong>同一个页面中加载所有需要显示的内容</strong>，而不是像传统的多页面应用一样在不同的页面中进行跳转。在 SPA 中，页面的局部更新是通过 JavaScript 操作 DOM 实现的，而不需要重新加载整个页面。通常，SPA 使用前端框架（如 Vue.js、React 等）来实现页面的组件化开发。</p>
<p>SPA 的优点包括：</p>
<ol>
<li><strong>用户体验好</strong>：由于整个页面的加载只发生一次，因此页面切换的速度快，用户体验更加流畅。</li>
<li><strong>前后端分离</strong>：前端负责页面的渲染和交互，后端只需要提供 API 接口，使得前后端的开发变得相对独立。</li>
<li><strong>更好的扩展性</strong>：由于前后端分离，可以针对不同的业务场景选择不同的技术栈，从而更好地实现扩展性。</li>
<li><strong>减轻服务器负担</strong>：由于前端负责页面的渲染，减少了服务器的负担，提高了服务器的性能。</li>
</ol>
<p>但是，SPA 也存在一些缺点：</p>
<ol>
<li><strong>首屏加载慢</strong>：由于所有内容都需要在首次加载时加载，因此首屏的加载速度可能会比较慢。</li>
<li><strong>SEO 不友</strong>好：由于只有一个页面，搜索引擎难以爬取所有的内容，对 SEO 不太友好。</li>
<li><strong>浏览器兼容性问题</strong>：某些浏览器不支持 HTML5 的 history API，这会影响 SPA 的路由跳转功能。</li>
<li><strong>前进、后退问题</strong>：由于只有一个页面，前进、后退等浏览器的行为需要自己进行处理，相对麻烦。</li>
</ol>
<p>因此，在选择 SPA 技术方案时，需要综合考虑其优缺点，并结合具体业务场景进行选择。</p>
<h5 id="如何解决首屏加载慢"><a href="#如何解决首屏加载慢" class="headerlink" title="如何解决首屏加载慢"></a>如何解决首屏加载慢</h5><p>首屏加载慢可能会给用户带来不好的体验，为了解决这个问题，可以考虑以下几个方面：</p>
<ol>
<li><p>代码优化：减少不必要的资源加载和代码执行。可以使用Webpack等打包工具对代码进行压缩和打包，去除未使用的代码和减小文件体积。还可以使用Code Splitting技术将大型的代码块分成较小的部分，使得页面可以逐步加载，而不是一次性加载整个页面。</p>
</li>
<li><p>图片优化：优化图片的加载方式，可以使用图片压缩工具对图片进行压缩处理，减小图片的体积，同时也可以使用懒加载技术，在页面滚动到该图片位置时才加载该图片。</p>
</li>
<li><p>服务端渲染：使用服务端渲染技术可以在服务端生成页面的HTML代码，将渲染的负担转移到服务器端，减轻客户端的压力，加快页面的加载速度。</p>
</li>
<li><p>CDN加速：使用CDN（内容分发网络）可以将静态资源缓存在全球各地的服务器上，当用户请求访问这些资源时，可以从离用户最近的服务器获取，从而加快资源的加载速度。</p>
</li>
<li><p>HTTP缓存：合理地使用HTTP缓存可以减少网络传输的时间，加快页面的加载速度。可以在服务器端设置缓存控制策略，告诉浏览器对哪些资源进行缓存，以及缓存的时间和方式等。</p>
</li>
</ol>
<h4 id="15-vue组件间传参方式"><a href="#15-vue组件间传参方式" class="headerlink" title="15.vue组件间传参方式"></a>15.vue组件间传参方式</h4><p>Vue 组件间通信的方式有以下几种：</p>
<ol>
<li>Props 和事件：父组件通过 Props 将数据传递给子组件，子组件则通过事件将数据传递给父组件。这是 Vue 组件通信最常用的方式之一。</li>
<li>EventBus&#x2F;事件总线：使用一个空的 Vue 实例作为事件总线，组件通过它来通信，从而避免了需要一层层传递 Props 的问题。</li>
<li>Vuex 状态管理：用于解决多个组件共享同一状态的问题，可以将需要共享的状态存储在 Vuex 的 store 中，任何组件都可以访问并修改这些状态。</li>
<li>$attrs 和 $listeners：在组件中，$attrs 包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。而 $listeners 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。</li>
<li>provide 和 inject：在祖先组件中 provide 一些数据，后代组件中使用 inject 来注入这些数据，从而实现了祖先与后代之间的通信。</li>
<li>$emit 和 $on：使用 Vue 实例的 $emit 方法触发事件，使用 $on 方法监听事件，从而实现组件之间的通信。</li>
</ol>
<p>需要根据具体业务场景和需求选择合适的通信方式。</p>
<h4 id="16-vue中key的作用"><a href="#16-vue中key的作用" class="headerlink" title="16.vue中key的作用"></a>16.vue中key的作用</h4><p>在 Vue 中，key 是用于识别 VNode 的一个特殊属性。<strong>每个 VNode 都可以拥有一个唯一的 key 值</strong>，<strong>用来判断 VNode 是否已经被渲染过。</strong></p>
<p>在使用 Vue 渲染列表时，通常会使用 v-for 指令来遍历数组或对象，将每个元素渲染成一个 VNode。此时，为了优化性能，Vue 会尝试尽可能地复用已经渲染过的 VNode，而不是重新渲染相同的元素。如果每个 VNode 拥有一个唯一的 key 值，Vue 就可以根据 key 值来判断哪些元素是已经渲染过的，哪些是新的元素需要重新渲染。</p>
<p>另外，key 还可以用于优化组件的渲染。当组件被更新时，如果它的 key 值没有改变，Vue 就会认为它是相同的组件，尝试重新使用已经创建的实例，而不是销毁和重新创建新的组件实例，从而提升渲染性能。</p>
<p>需要注意的是，key 必须是唯一且稳定的。不同的 VNode 应该拥有不同的 key 值，同一个 VNode 的 key 值应该在更新过程中保持不变。如果 key 值不稳定，可能会导致渲染错误和性能问题。</p>
<p>在 Vue 中，key 是用来给 Vue 中的 v-for 指令渲染的列表中的每个子节点分配一<strong>个唯一标识符</strong>的。这个 key 值可以用来在 Vue 的虚拟 DOM 算法中，更高效地更新视图。</p>
<p>当数据发生变化时，Vue 会根据新数据生成一颗新的虚拟 DOM 树，与旧的虚拟 DOM 树进行比较，并更新实际的 DOM 树。此时如果没有为每个节点指定一个 key 值，则 Vue 会默认使用节点在列表中的索引作为 key 值。</p>
<p>如果列表中的数据发生变化，导致某个节点的位置发生变化或者有节点被添加或者删除，Vue 会遍历新旧虚拟 DOM 树，对比节点的 key 值是否相同。如果节点的 key 值不同，Vue 会认为这是不同的节点，从而在重新渲染时，直接销毁旧节点，创建新节点。如果节点的 key 值相同，Vue 会认为这是相同的节点，然后更新节点的属性，从而实现更高效的渲染。</p>
<p>因此，为每个节点指定唯一的 key 值，可以<strong>避免因为节点顺序、增删等变化导致的不必要的 DOM 更新，提高应用的性能。</strong></p>
<p>总的来说，key 的作用是帮助 Vue 更好地识别每个节点的唯一性，从而正确地更新或复用节点，提高页面渲染效率。</p>
<h4 id="17-虚拟dom"><a href="#17-虚拟dom" class="headerlink" title="17.虚拟dom"></a>17.虚拟dom</h4><p>虚拟 DOM（Virtual DOM）是浏览器中的一个概念，用于<strong>表示真实 DOM 的 JavaScript 对象树</strong>。Vue 和 React 等现代前端框架都是使用虚拟 DOM 来实现高效的页面渲染。</p>
<p>虚拟 DOM 的工作原理是将真实 DOM 的结构表示成一颗树形结构，每个节点表示一个 DOM 元素，每个节点都有对应的属性和子节点。当数据发生变化时，虚拟 DOM 会将新的数据映射到新的虚拟 DOM 树上，并与旧的虚拟 DOM 树进行比较，找出需要更新的部分。最终，虚拟 DOM 会将这些需要更新的部分渲染到真实 DOM 上。</p>
<p>通过使用虚拟 DOM，框架可以在渲染组件时，只对需要更新的部分进行操作，从而避免了无效的 DOM 操作。这样可以大大提高页面的性能和用户体验。</p>
<p>需要注意的是，虚拟 DOM 也不是完美的，它在性能上的提升也有一定的局限性。因为虚拟 DOM 本身也是一个 JavaScript 对象，如果要进行大量的更新，其操作也可能会变得比较耗时。因此，在实际应用中，我们还需要根据具体情况进行综合考虑，选择最优的方案来实现页面渲染和数据更新。</p>
<h5 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h5><p>虚拟 DOM 的实现过程可以简单地概括为以下几个步骤：</p>
<ol>
<li><p>初始化：在页面初始化时，将所有的真实 DOM 转换成虚拟 DOM。</p>
</li>
<li><p>渲染：将虚拟 DOM 渲染成真实 DOM 并插入到页面中。</p>
</li>
<li><p>更新：当数据发生变化时，生成新的虚拟 DOM 并将其与旧的虚拟 DOM 进行比较，找出需要更新的部分。</p>
</li>
<li><p>重新渲染：将需要更新的部分重新渲染成真实 DOM，并替换旧的 DOM。</p>
</li>
</ol>
<p>具体实现过程中，虚拟 DOM 可以被描述为一个 JavaScript 对象树，它是一个轻量级的数据结构，因此可以很快地进行比较和操作。在 Vue 中，每个组件都对应一个虚拟 DOM 树，当组件的状态发生变化时，Vue 会重新生成一个新的虚拟 DOM 树，并将其与旧的虚拟 DOM 树进行比较，从而找出需要更新的部分，最后将这些需要更新的部分重新渲染成真实 DOM 并插入到页面中。</p>
<h4 id="18-watch和watchEffect的区别？（vue3"><a href="#18-watch和watchEffect的区别？（vue3" class="headerlink" title="18.watch和watchEffect的区别？（vue3)"></a>18.watch和watchEffect的区别？（vue3)</h4><p><code>watch</code> 和 <code>watchEffect</code> 都是监听器，<code>watchEffect</code> 是一个副作用函数。它们之间的区别有：</p>
<ul>
<li><code>watch</code> ：既要指明监视的数据源，也要指明监视的回调。</li>
<li>而 <code>watchEffect</code> 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</li>
<li><code>watch</code> 可以访问<code>改变之前和之后</code>的值，<code>watchEffect</code> 只能获取<code>改变后</code>的值。</li>
<li><code>watch</code> 运行的时候<code>不会立即执行</code>，值改变后才会执行，而 <code>watchEffect</code> 运行后可<code>立即执行</code>。这一点可以通过 <code>watch</code> 的配置项 <code>immediate</code> 改变。</li>
<li><code>watchEffect</code>有点像 <code>computed</code> ：<ul>
<li>但 <code>computed</code> 注重的计算出来的值（回调函数的返回值）， 所以必须要写返回值。</li>
<li>而 <code>watcheffect</code>注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a343493e42514a9a8b78d8b8d43ca7a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<p><code>watch</code>与 <code>vue2.x</code>中 <code>watch</code> 配置功能一致，但也有两个小坑</p>
<ul>
<li>监视 <code>reactive</code> 定义的响应式数据时，<code>oldValue</code> 无法正确获取，强<code>制开启</code>了深度监视（deep配置失效）</li>
<li>监视 <code>reactive</code> 定义的响应式数据中<code>某个属性</code>时，<code>deep配置有效</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;你好啊&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">	<span class="attr">job</span>:&#123;</span><br><span class="line">		<span class="attr">j1</span>:&#123;</span><br><span class="line">			<span class="attr">salary</span>:<span class="number">20</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况1：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue, oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum变化了&quot;</span>, newValue, oldValue),(<span class="attr">immediate</span>:<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//情况2：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum, msg],<span class="function">(<span class="params">newValue, oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum或msg变化了&quot;</span>, newValue, oldValue),(<span class="attr">immediate</span>:<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//情况3：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">//若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue，且强制开启了深度监视。</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue, oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person变化了&quot;</span>, newValue, oldValue),(<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>) <span class="comment">//此处的deep配置不再生效。</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//情况4：监视reactive所定义的一个响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">name</span>,<span class="function">(<span class="params">newValue, oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person.name变化了&quot;</span>, newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//情况5：监视reactive所定义的一个响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">name</span>, <span class="function">()=&gt;</span>person.<span class="property">age</span>],<span class="function">(<span class="params">newValue, oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person.name或person.age变化了&quot;</span>, newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//特殊情况：</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue, oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person.job变化了&quot;</span>, newValue, oldValue)</span><br><span class="line">&#125;, &#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>19.script setup 是干啥的？</p>
<p><code>scrtpt setup</code> 是 <code>vue3</code> 的语法糖，简化了<code>组合式 API</code> 的写法，并且运行性能更好。使用 <code>script setup</code> 语法糖的特点：</p>
<ul>
<li><strong>属性和方法无需返回</strong>，可以直接使用。</li>
<li>引入<code>组件</code>的时候，会<code>自动注册</code>，无需通过 <code>components</code> 手动注册。</li>
<li>使用 <code>defineProps</code> 接收父组件传递的值。</li>
<li><code>useAttrs</code> 获取属性，<code>useSlots</code> 获取插槽，<code>defineEmits</code> 获取自定义事件。</li>
<li>默认<code>不会对外暴露</code>任何属性，如果有需要可使用 <code>defineExpose</code> 。</li>
</ul>
<h4 id="19-vue2和vue3-核心-diff-算法区别"><a href="#19-vue2和vue3-核心-diff-算法区别" class="headerlink" title="19.vue2和vue3 核心 diff 算法区别"></a>19.vue2和vue3 核心 diff 算法区别</h4><p>Vue 2.x使用的是<strong>双向指针遍历的算法</strong>，也就是通过逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。</p>
<p>Vue 3.x使用了经过优化的单向遍历算法，也就是<strong>只扫描新虚拟DOM树上的节点</strong>，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能。</p>
<p>因此，总体来说，Vue 3相对于Vue 2拥有更高效、更智能的diff算法，能够更好地避免不必要的操作，并提高了渲染性能。</p>
<h4 id="20-Composition-API-和-Options-API"><a href="#20-Composition-API-和-Options-API" class="headerlink" title="20.Composition API 和 Options API"></a>20.Composition API 和 Options API</h4><p>Composition API 和 Options API 都是 Vue.js 提供的 API，用于编写组件的逻辑部分。它们的区别在于编写方式和适用场景。</p>
<p>Options API 是 Vue.js 2.x 中最常用的组件编写方式，通过在组件选项中定义 data、methods、computed 等属性和方法来实现组件的逻辑。Options API 编写方式的优点是简单易学，容易上手，适用于小型和中等规模的应用。</p>
<p>Composition API 是 Vue.js 3.x 中新增的组件编写方式，它通过一组函数和钩子来定义组件的逻辑，以及通过 setup 函数来访问组件的数据和方法。Composition API 编写方式的优点是可以更好地组织和重用代码，提高了代码的可读性和可维护性，适用于大型和复杂的应用。</p>
<p>相对于 Options API，Composition API 具有以下优点：</p>
<ol>
<li><p><strong>更好的组织和重用代码</strong>：通过将逻辑分解为可重用的函数和模块，使得代码更加清晰和易于维护。</p>
</li>
<li><p><strong>更好的类型推导</strong>：使用 Composition API 编写的组件可以更加容易地进行类型推导，从而提高了代码的健壮性和可维护性。</p>
</li>
<li><p><strong>更加灵活</strong>：Composition API 提供了更多的钩子和函数，使得开发者可以更加灵活地处理组件的逻辑和数据。</p>
</li>
</ol>
<p>总的来说，Composition API 是一个更加灵活、可重用和可维护的组件编写方式，适用于大型和复杂的应用。而 Options API 则适用于小型和中等规模的应用，具有简单易学和快速开发的优点。</p>
<h4 id="vue3的优点"><a href="#vue3的优点" class="headerlink" title="vue3的优点"></a>vue3的优点</h4><p>Vue3 是 Vue 框架的最新版本，相对于 Vue2，它有以下几个优点：</p>
<ol>
<li><p><strong>更快的渲染速度</strong></p>
<p>Vue3 通过重写响应式系统，使用了基于 Proxy 的观察者模式，使得响应式数据的获取和更新速度更快，从而提高了整个框架的渲染速度。此外，Vue3 还提供了静态提升和组件缓存等优化策略，进一步提高了渲染性能。</p>
</li>
<li><p><strong>更小的体积</strong></p>
<p>Vue3 采用了 tree-shaking 技术，将整个框架分成多个小模块，从而使得开发者可以只引入需要的模块，从而减少整个框架的体积。此外，Vue3 还优化了内部代码结构和实现方式，使得整个框架的体积更小。</p>
</li>
<li><p><strong>更好的 TypeScript 支持</strong></p>
<p>Vue3 对 TypeScript 的支持更加完善，内部代码也更加类型安全。Vue3 提供了完整的 TypeScript 声明文件，并对其进行了优化，使得开发者可以更加轻松地使用 TypeScript 进行开发。</p>
</li>
<li><p><strong>更加灵活的组合式 API</strong></p>
<p>Vue3 引入了 Composition API，使得开发者可以更加灵活地组合组件逻辑，并且代码结构更加清晰易读。相比于 Vue2 的 Options API，Composition API 可以更好地解决组件复用和逻辑复杂性的问题。</p>
</li>
</ol>
<p>然而，Vue3 也存在一些缺点：</p>
<ol>
<li><p>对 IE11 支持不够友好</p>
<p>Vue3 采用了一些现代 JavaScript 的语言特性，例如 Proxy 和 Reflect 等，这些特性在 IE11 中并不完全支持。因此，在需要兼容 IE11 的项目中，使用 Vue3 可能会存在一些问题。</p>
</li>
<li><p>学习成本相对较高</p>
<p>Vue3 引入了 Composition API，并且对原有的 Options API 进行了一些改动，因此对于之前只使用过 Vue2 的开发者来说，需要学习新的 API，并且需要适应新的开发方式，这可能会增加一些学习成本。</p>
</li>
<li><p>插件和生态库尚不完善</p>
<p>相比于 Vue2，Vue3 的生态库和插件尚不完善，有些插件和库可能还没有完全支持 Vue3，这可能会对项目的开发带来一些不便。不过随着 Vue3 的普及和生态的完善，这个问题将会逐渐得到解决。</p>
</li>
</ol>
<p>总之，Vue3 相对于 Vue2，具有更快的渲染速度、更小的体积、更好的 TypeScript 支持和更加灵</p>
<h4 id="vue2和vue3的不同之处"><a href="#vue2和vue3的不同之处" class="headerlink" title="vue2和vue3的不同之处"></a>vue2和vue3的不同之处</h4><p>Vue2 和 Vue3 是 Vue.js 框架的两个主要版本，它们之间有以下几个不同之处：</p>
<ol>
<li><p><strong>响应式系统的实现方式</strong></p>
<p>Vue2 使用的是基于 Object.defineProperty 的响应式系统，而 Vue3 使用了基于 Proxy 的响应式系统，使得 Vue3 的响应式数据的获取和更新速度更快，从而提高了整个框架的渲染速度。</p>
</li>
<li><p><strong>组合式 API</strong></p>
<p>Vue3 引入了组合式 API，使得开发者可以更加灵活地组合组件逻辑，并且代码结构更加清晰易读。相比于 Vue2 的 Options API，Composition API 可以更好地解决组件复用和逻辑复杂性的问题。</p>
</li>
<li><p>编译器的改进</p>
<p>Vue3 的编译器进行了一些改进，可以将模板编译成更加高效的渲染函数，从而<strong>提高了渲染性能</strong>。</p>
</li>
<li><p>静态提升</p>
<p>Vue3 引入了静态提升的技术，可以在编译阶段将一些静态的节点和属性提升到 render 函数外部，从而减少了渲染函数的执行次数，提高了渲染性能。</p>
<p><strong>静态提升</strong>（Static Hoisting）是 Vue 3 新增的一项性能优化技术，<strong>它可以在编译阶段将一些静态的节点和属性提升到渲染函数的外部，从而减少渲染函数的执行次数，提高渲染性能。</strong></p>
<p>在 Vue 2 中，每次组件渲染都需要重新生成渲染函数。而在 Vue 3 中，由于静态节点和属性不会随着组件状态的变化而发生变化，因此可以将它们在编译阶段提取出来，生成一个静态的渲染函数，从而避免了每次渲染都需要重新生成渲染函数的问题。</p>
<h6 id="静态提升不仅可以提高渲染性能，还可以减少组件的更新开销，从而提高整个应用的性能表现。"><a href="#静态提升不仅可以提高渲染性能，还可以减少组件的更新开销，从而提高整个应用的性能表现。" class="headerlink" title="静态提升不仅可以提高渲染性能，还可以减少组件的更新开销，从而提高整个应用的性能表现。"></a>静态提升不仅可以提高渲染性能，还可以减少组件的更新开销，从而提高整个应用的性能表现。</h6></li>
<li><p>其他优化</p>
<p>Vue3 对整个框架进行了一些优化，包括了更小的体积、更好的 TypeScript 支持、更好的 TypeScript 支持和更加友好的错误提示等。</p>
</li>
</ol>
<p>除此之外，Vue3 还支持 Suspense 和 Teleport 等新的特性，可以更加方便地实现异步组件和组件之间的跨越式渲染等功能。同时，Vue3 也去掉了一些不常用的 API，使得整个框架更加简洁。</p>
<p>总之，Vue3 相比于 Vue2，在性能、开发体验和新特性等方面都有不同程度的提升，因此在新项目中可以考虑使用 Vue3。如果是已有的 Vue2 项目，也可以逐步升级到 Vue3，以获得更好的开发体验和性能优化。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">killzou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/c0add594.html">http://example.com/post/c0add594.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">好困啊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/zoublong/tags/vue/">vue</a></div><div class="post_share"><div class="social-share" data-image="https://cli.vuejs.org/favicon.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/zoublong/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/zoublong/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/zoublong/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/zoublong/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/zoublong/post/a8829c43.html" title="防抖节流"><img class="cover" src="https://s1.vika.cn/space/2023/05/01/ab2932221f164f34a79e548a73f645e0" onerror="onerror=null;src='/zoublong/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">防抖节流</div></div></a></div><div class="next-post pull-right"><a href="/zoublong/post/bc9ada0c.html" title="js -2"><img class="cover" src="https://s1.vika.cn/space/2023/05/01/ab2932221f164f34a79e548a73f645e0" onerror="onerror=null;src='/zoublong/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">js -2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/zoublong/post/27f15615.html" title="vue3应知应会"><img class="cover" src="https://cli.vuejs.org/favicon.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="title">vue3应知应会</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://p1.music.126.net/bKM7itpIqu_G2cA4BwdHmw==/109951168552935844.jpg" onerror="this.onerror=null;this.src='/zoublong/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kill zou</div><div class="author-info__description">困了不睡睡，熬成仙</div></div><div class="card-info-data site-data is-center"><a href="/zoublong/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/zoublong/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/zoublong/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/killzou"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zouwenhao03" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:13588824132@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-vue%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">1.vue的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MVVM"><span class="toc-number">2.</span> <span class="toc-text">2.MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MVC%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">MVC：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">两者的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3.双向数据绑定原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">如何实现的：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue3"><span class="toc-number">3.2.</span> <span class="toc-text">vue3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-defineProperty-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">Object.defineProperty()的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue-set%E6%98%AF%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">vue.$set是实现的原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-vue-computed-%E5%92%8Cwatch"><span class="toc-number">4.</span> <span class="toc-text">4.vue computed 和watch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-slot%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.slot是什么？有什么作用？原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.</span> <span class="toc-text">6.vue生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vue3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.1.</span> <span class="toc-text">vue3的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%84%E4%BB%B6%EF%BC%88%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%EF%BC%89%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">多组件（父子组件）中生命周期的调用顺序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-v-model%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">7.</span> <span class="toc-text">7.v-model双向绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-vue-router"><span class="toc-number">8.</span> <span class="toc-text">8.vue-router</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-hash%E5%92%8Chistory%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.</span> <span class="toc-text">1.hash和history的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#router%E5%92%8Croute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">router和route的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-number">8.3.</span> <span class="toc-text">路由守卫</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-v-if-%E4%B8%8E-v-show-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">9.v-if 与 v-show 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.</span> <span class="toc-text">10.v-if和v-for的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-keep-alive"><span class="toc-number">11.</span> <span class="toc-text">11.keep-alive</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#keep-alive%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">11.1.</span> <span class="toc-text">keep-alive的实现原理是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8Ekeep-alive%E7%9B%B8%E5%85%B3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E8%BF%9B%E8%A1%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">与keep-alive相关的生命周期函数是什么，什么场景下会进行使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#keep-alive%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">11.3.</span> <span class="toc-text">keep-alive的常用属性有哪些</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-nextTick"><span class="toc-number">12.</span> <span class="toc-text">12.$nextTick</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-nextTick"><span class="toc-number">12.1.</span> <span class="toc-text">为什么要使用$nextTick</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">13.data为什么是个函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-spa%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">14.</span> <span class="toc-text">14.spa的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E6%85%A2"><span class="toc-number">14.1.</span> <span class="toc-text">如何解决首屏加载慢</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">15.vue组件间传参方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-vue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">16.vue中key的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%99%9A%E6%8B%9Fdom"><span class="toc-number">17.</span> <span class="toc-text">17.虚拟dom</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">17.1.</span> <span class="toc-text">实现步骤：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-watch%E5%92%8CwatchEffect%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88vue3"><span class="toc-number">18.</span> <span class="toc-text">18.watch和watchEffect的区别？（vue3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-vue2%E5%92%8Cvue3-%E6%A0%B8%E5%BF%83-diff-%E7%AE%97%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">19.vue2和vue3 核心 diff 算法区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-Composition-API-%E5%92%8C-Options-API"><span class="toc-number">20.</span> <span class="toc-text">20.Composition API 和 Options API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue3%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">21.</span> <span class="toc-text">vue3的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue2%E5%92%8Cvue3%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">22.</span> <span class="toc-text">vue2和vue3的不同之处</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%8F%90%E5%8D%87%E4%B8%8D%E4%BB%85%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%87%8F%E5%B0%91%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0%E5%BC%80%E9%94%80%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%8F%90%E9%AB%98%E6%95%B4%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0%E3%80%82"><span class="toc-number">22.0.1.</span> <span class="toc-text">静态提升不仅可以提高渲染性能，还可以减少组件的更新开销，从而提高整个应用的性能表现。</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/zoublong/post/49dd0961.html" title="山里"><img src="/zoublong/img/5920.jpg" onerror="this.onerror=null;this.src='/zoublong/img/404.jpg'" alt="山里"/></a><div class="content"><a class="title" href="/zoublong/post/49dd0961.html" title="山里">山里</a><time datetime="2023-05-06T00:18:11.268Z" title="发表于 2023-05-06 08:18:11">2023-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/zoublong/post/a8829c43.html" title="防抖节流"><img src="https://s1.vika.cn/space/2023/05/01/ab2932221f164f34a79e548a73f645e0" onerror="this.onerror=null;this.src='/zoublong/img/404.jpg'" alt="防抖节流"/></a><div class="content"><a class="title" href="/zoublong/post/a8829c43.html" title="防抖节流">防抖节流</a><time datetime="2023-05-03T05:35:58.697Z" title="发表于 2023-05-03 13:35:58">2023-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/zoublong/post/c0add594.html" title="vue"><img src="https://cli.vuejs.org/favicon.png" onerror="this.onerror=null;this.src='/zoublong/img/404.jpg'" alt="vue"/></a><div class="content"><a class="title" href="/zoublong/post/c0add594.html" title="vue">vue</a><time datetime="2023-05-02T01:39:59.635Z" title="发表于 2023-05-02 09:39:59">2023-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/zoublong/post/bc9ada0c.html" title="js -2"><img src="https://s1.vika.cn/space/2023/05/01/ab2932221f164f34a79e548a73f645e0" onerror="this.onerror=null;this.src='/zoublong/img/404.jpg'" alt="js -2"/></a><div class="content"><a class="title" href="/zoublong/post/bc9ada0c.html" title="js -2">js -2</a><time datetime="2023-04-30T02:28:07.529Z" title="发表于 2023-04-30 10:28:07">2023-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/zoublong/post/e36b6b5c.html" title="js输出题"><img src="https://s1.vika.cn/space/2023/05/01/ab2932221f164f34a79e548a73f645e0" onerror="this.onerror=null;this.src='/zoublong/img/404.jpg'" alt="js输出题"/></a><div class="content"><a class="title" href="/zoublong/post/e36b6b5c.html" title="js输出题">js输出题</a><time datetime="2023-04-30T00:38:34.708Z" title="发表于 2023-04-30 08:38:34">2023-04-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/zoublong/js/utils.js"></script><script src="/zoublong/js/main.js"></script><script src="/zoublong/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://www.940329.xyz/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://www.940329.xyz/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div id="fps"></div><canvas id="universe"></canvas><script defer src="/zoublong/config/js/universe.js"></script><script defer src="/zoublong/config/js/fap.js"></script><script defer src="/zoublong/config/js/title.js"></script><canvas id="snow"></canvas><script defer src="/zoublong/config/js/snow.js"></script><script defer src="/zoublong/config/js/console.js"></script><script defer src="//at.alicdn.com/t/c/font_4029980_g3l7ofih7zt.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/zoublong/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/zoublong/';
  var qweather_key = 'a0ba29844888417aa67d36cca441e9e0';
  var gaud_map_key = '5e25390a192c00c9a9c6303ffb26d4ba';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/zoublong/config/js/runtime.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/zoublong/zoublong/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"zoublong/","pluginJsPath":"live2dw/lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/zoublong/zoublong/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>